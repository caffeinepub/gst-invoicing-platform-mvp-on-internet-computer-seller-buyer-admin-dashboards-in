{
  "kind": "build_request",
  "title": "Add live energy readings ingestion + near-real-time dashboard updates with authenticated streaming/polling",
  "priority": "normal",
  "requirements": [
    {
      "id": "REQ-1",
      "text": "Backend: Add an authenticated ingestion API for incoming real-time energy readings from sensors/external energy APIs, including validation and normalization for these metrics: appliance power usage (Watts), solar generation (kW), battery charge level (%), and grid import/export.",
      "target": "backend",
      "source": {
        "messageIds": [
          "msg-4"
        ],
        "quotes": [
          "Sensors / external APIs push live energy readings",
          "Backend validates, normalizes, and stores data",
          "Stream: Appliance power usage (Watts) / Solar generation (kW) / Battery charge level (%) / Grid import/export",
          "Validate incoming sensor data"
        ]
      },
      "acceptanceCriteria": [
        "Backend rejects malformed readings with a clear error (no traps) and does not persist invalid data.",
        "Backend normalizes units/fields into a single canonical reading shape before storing/serving.",
        "Ingestion is protected so unauthenticated callers cannot submit readings."
      ]
    },
    {
      "id": "REQ-2",
      "text": "Backend: Persist and serve time-ordered energy readings in the single Motoko actor (backend/main.mo), providing query methods to fetch (a) the latest reading per metric and (b) incremental updates since a provided timestamp (or cursor) to support low-latency UI updates and fault-tolerant recovery after disconnects.",
      "target": "backend",
      "source": {
        "messageIds": [
          "msg-4"
        ],
        "quotes": [
          "Replace static or batch data with real-time streaming data",
          "Ensure low latency, fault tolerance, and scalability",
          "Backend validates, normalizes, and stores data",
          "Throttling and error recovery",
          "Reconnection handling"
        ]
      },
      "acceptanceCriteria": [
        "There is a query that returns the latest known values for all four metric groups in a single response.",
        "There is a query that returns readings since a client-provided timestamp/cursor, ordered by time, with a bounded maximum payload size (throttling).",
        "Client can resume after a disconnect by calling the incremental query with its last-seen timestamp/cursor without losing ordering."
      ]
    },
    {
      "id": "REQ-3",
      "text": "Backend: Implement authorization checks suitable for real-time consumers, using the existing authenticated session model (frontend stores the token under localStorage key \"auth_token\") and ensuring only authenticated users can access live readings APIs.",
      "target": "backend",
      "source": {
        "messageIds": [
          "msg-4"
        ],
        "quotes": [
          "Authenticate real-time connections using JWT",
          "Authentication for socket connections"
        ]
      },
      "acceptanceCriteria": [
        "Unauthenticated access to live readings APIs fails with a clear unauthorized error.",
        "Authenticated access succeeds consistently for live readings queries.",
        "Authorization checks are centralized and consistently applied across ingestion and live-read APIs."
      ]
    },
    {
      "id": "REQ-4",
      "text": "Frontend: Create a dedicated real-time client service (in TypeScript) that attempts to connect to a live stream endpoint (WebSocket: ws://api/energy/live OR SSE: GET /api/energy/stream) when available, and otherwise falls back to incremental polling against the backend live-read APIs; the service must manage the connection lifecycle, auto-reconnect with backoff, throttling of UI updates, and error recovery.",
      "target": "frontend",
      "source": {
        "messageIds": [
          "msg-4"
        ],
        "quotes": [
          "Create a real-time endpoint: ws://api/energy/live OR GET /api/energy/stream",
          "Create a dedicated real-time service: realTimeService.js",
          "Handle: Connection lifecycle / Auto-reconnect / Fallback to REST if stream fails",
          "Throttling and error recovery"
        ]
      },
      "acceptanceCriteria": [
        "Real-time service attaches the JWT from localStorage(\"auth_token\") to the stream connection (SSE header or WS token mechanism) and to fallback HTTP requests.",
        "If the stream fails to connect or drops, the service transitions to DISCONNECTED and retries with exponential backoff; on recovery it resumes using last-seen timestamp/cursor.",
        "If both stream and live polling fail, the UI continues to function using existing REST fetch flows (e.g., fetchConsumption/fetchSolarAnalysis/fetchCostEstimation) without crashing.",
        "Update emission to UI is throttled/batched so rapid incoming readings do not cause excessive re-renders."
      ]
    },
    {
      "id": "REQ-5",
      "text": "Frontend: Add shared live-telemetry state (React context + hooks) that exposes (a) latest readings, (b) a rolling average per metric over a short window, (c) connection status (LIVE/DISCONNECTED), and (d) data freshness timestamps; integrate it into existing authenticated routes/pages.",
      "target": "frontend",
      "source": {
        "messageIds": [
          "msg-4"
        ],
        "quotes": [
          "Frontend: React (hooks, context)",
          "Display: Live charts / Rolling averages / Status indicators (LIVE / DISCONNECTED)",
          "Timestamped readings",
          "Visual indicators for data freshness"
        ]
      },
      "acceptanceCriteria": [
        "Components can subscribe to live readings via a hook without prop-drilling.",
        "Connection status is available globally to energy module pages and updates immediately on connect/disconnect.",
        "Rolling averages are computed client-side from the recent reading window and exposed in the same hook/context.",
        "Each metric group includes a last-updated timestamp that the UI can render."
      ]
    },
    {
      "id": "REQ-6",
      "text": "Frontend: Update the Energy Consumption module (/consumption), Solar Allocation & Analysis module (/solar-analysis), and Cost Estimation module (/cost-estimation) to display live-updating values, status indicators (LIVE/DISCONNECTED), and clear data-freshness timestamps, with smooth transitions for value changes; keep existing loading/error/empty states compatible.",
      "target": "frontend",
      "source": {
        "messageIds": [
          "msg-4"
        ],
        "quotes": [
          "Update UI in: Energy Consumption Module / Solar Allocation & Analysis Module / Cost Estimation Module",
          "Live-updating graphs (no refresh)",
          "Status indicators (LIVE / DISCONNECTED)",
          "Visual indicators for data freshness",
          "Smooth transitions for value changes"
        ]
      },
      "acceptanceCriteria": [
        "Each of the three pages shows a LIVE/DISCONNECTED badge and a “Last updated” timestamp.",
        "When live data is available, headline metrics update automatically without requiring the user to click “Fetch Data”.",
        "Transitions for changing numeric values are visually smooth (no abrupt jumps), and stale data is visually indicated when disconnected.",
        "Existing manual “Fetch Data” behavior still works as a fallback and does not conflict with live updates."
      ]
    },
    {
      "id": "REQ-7",
      "text": "Frontend: Add lightweight logging hooks for real-time ingestion/streaming health (connect/disconnect events, retry counts, last message time, and error reasons) and ensure logs do not expose JWTs or sensitive user data.",
      "target": "frontend",
      "source": {
        "messageIds": [
          "msg-4"
        ],
        "quotes": [
          "Logging and monitoring hooks",
          "Graceful degradation on network loss"
        ]
      },
      "acceptanceCriteria": [
        "Real-time service emits structured, non-sensitive logs for connection lifecycle events.",
        "Errors include actionable reasons (e.g., unauthorized, network error, parse error) without printing tokens.",
        "Logs can be disabled or reduced in production builds via a simple configuration flag."
      ]
    }
  ],
  "constraints": [
    "Backend must remain a single Motoko actor in backend/main.mo; do not introduce additional backend services.",
    "Do not modify files under frontend/src/components/ui (read-only).",
    "Do not edit frontend immutable hook files (frontend/src/hooks/useInternetIdentity.ts, frontend/src/hooks/useInternetIdentity.tsx, frontend/src/hooks/useActor.ts, frontend/src/main.tsx).",
    "Use English for any user-facing text.",
    "Respect platform limitations: do not require Node.js/Spring Boot servers, external databases (PostgreSQL/TimescaleDB/MongoDB), Redis, WebSockets infrastructure, or third-party monitoring services to be provisioned by this project."
  ],
  "nonGoals": [
    "Implementing TimescaleDB/PostgreSQL/MongoDB storage or Redis caching (not supported in this environment).",
    "Implementing a true WebSocket server in the backend canister if the platform runtime does not support it; polling-based near-real-time is acceptable as the fallback.",
    "Adding third-party authentication providers; keep the current authentication approach and token storage model.",
    "Building a full observability/monitoring stack beyond lightweight internal logging hooks."
  ],
  "imageRequirements": {
    "required": [],
    "edits": []
  },
  "userProfileUpdate": {
    "goalsToAdd": [],
    "goalsToRemove": [],
    "preferencesToAdd": [],
    "preferencesToRemove": [],
    "miscToAdd": [],
    "miscToRemove": [],
    "fieldsToSet": {},
    "fieldsToDelete": []
  }
}